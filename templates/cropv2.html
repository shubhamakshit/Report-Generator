<!doctype html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1">
    <title>Step 2: Draw Boxes ({{ image_index + 1 }} / {{ total_pages }})</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <style>
        /* GLOBAL LAYOUT RESET */
        html, body { 
            height: 100%; 
            width: 100%; 
            margin: 0; 
            padding: 0; 
            overflow: hidden; /* CRITICAL: Disable global scroll */
        }

        /* MAIN FLEX CONTAINER */
        .main-container { 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            width: 100vw; 
            overflow: hidden; 
        }

        /* HEADER */
        .app-header { 
            height: 56px; 
            flex-shrink: 0; 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            padding: 0 1rem; 
            background: #2c3034; 
            border-bottom: 1px solid #495057; 
        }
        .header-title { font-size: 1.1rem; font-weight: 500; margin: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .header-actions { display: flex; gap: 0.5rem; }

        /* CONTENT WRAPPER (Image + Controls) */
        .content-wrapper { 
            flex: 1; /* Fills remaining height after header */
            display: flex; 
            flex-direction: column; 
            min-height: 0; /* CRITICAL: Allows flex child to shrink below content size */
            overflow: hidden; 
            position: relative;
        }

        /* IMAGE PANE (The resize container) */
        .image-pane { 
            flex-grow: 1; 
            position: relative; 
            background: #181a1c; 
            overflow: hidden; /* Clips anything that tries to stick out */
            display: flex; 
            align-items: center; 
            justify-content: center;
            min-height: 0; /* CRITICAL for preventing scroll */
            width: 100%;
        }

        /* CROP AREA (Wrapper for Img + Canvas) */
        /* Width/Height set by JS to strictly fit */
        #crop-area { 
            position: relative; 
            line-height: 0; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #main-image { 
            display: block; 
            width: 100%; 
            height: 100%; 
            pointer-events: none; 
        }

        #draw-canvas {
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 10;
            cursor: crosshair;
            touch-action: none;
        }

        /* CONTROLS PANE */
        .controls-pane { 
            flex-shrink: 0; 
            background: #212529; 
            border-top: 1px solid #495057; 
            height: 280px; /* Fixed height on mobile */
            overflow-y: auto; 
            z-index: 30; 
        }
        .controls-content { padding: 1rem; }

        /* DESKTOP MEDIA QUERY */
        @media (min-width: 992px) { 
            .content-wrapper { flex-direction: row; } 
            .controls-pane { 
                width: 320px; 
                height: 100%; 
                border-top: none; 
                border-left: 1px solid #495057; 
            } 
        }

        /* FLOATING TOOLBAR */
        #box-toolbar { position: absolute; background: rgba(44, 48, 52, 0.95); border: 1px solid #6c757d; border-radius: 6px; padding: 4px; display: none; z-index: 100; backdrop-filter: blur(5px); }
        #box-toolbar button { background: transparent; border: none; color: #e9ecef; padding: 6px 8px; font-size: 1.1rem; }
        #box-toolbar button:hover { color: #fff; background: rgba(255,255,255,0.2); border-radius: 4px; }

        /* UTILS */
        #loader-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 9999; display: none; align-items: center; justify-content: center; }
        .status-message { position: fixed; top: 70px; left: 50%; transform: translateX(-50%); z-index: 1050; max-width: 90%; }
    </style>
</head>
<body>
    {% include '_navbar.html' %}
    
    <div id="loader-overlay">
        <div class="spinner-border text-light" role="status"><span class="visually-hidden">Loading...</span></div>
    </div>

    <div class="main-container">
        <header class="app-header">
             <h1 class="header-title"><i class="bi bi-bounding-box me-2"></i>Page {{ image_index + 1 }} / {{ total_pages }}</h1>
             <div class="header-actions">
                <button id="backBtn" class="btn btn-secondary btn-sm"><i class="bi bi-arrow-left"></i> Back</button>
                <button id="clearBtn" class="btn btn-info btn-sm"><i class="bi bi-eraser"></i> Clear</button>
                <button id="processBtn" class="btn btn-success btn-sm">Process <i class="bi bi-check-lg"></i></button>
            </div>
        </header>

        <div class="content-wrapper">
            <div class="image-pane" id="imagePane">
                <div id="stitch-instructions" class="alert alert-warning position-absolute top-0 start-50 translate-middle-x mt-2" style="z-index: 20; display: none; font-size: 0.9rem; width: 90%;"></div>
                
                <div id="crop-area">
                    <img id="main-image" src="/image/upload/{{ image_info.filename }}" alt="PDF Page" crossorigin="anonymous">
                    <canvas id="draw-canvas"></canvas>
                    
                    <div id="box-toolbar">
                        <button id="stitch-btn" title="Stitch"><i class="bi bi-scissors"></i></button>
                        <button id="move-up-btn" title="Move Up"><i class="bi bi-arrow-up-circle"></i></button>
                        <button id="move-down-btn" title="Move Down"><i class="bi bi-arrow-down-circle"></i></button>
                        <button id="delete-btn" title="Delete Box"><i class="bi bi-trash"></i></button>
                    </div>
                </div>
            </div>

            <div class="controls-pane">
                 <div class="controls-content">
                    <div class="alert alert-info small p-2 mb-3"><i class="bi bi-info-circle me-2"></i>Draw boxes on the image.</div>
                    <h6 class="text-white mb-3">Filters</h6>
                    <div class="mb-2"><label class="small text-light d-flex justify-content-between">Brightness <span id="brightnessValue" class="text-primary">0</span></label><input type="range" class="form-range" id="brightness" min="-100" max="100" value="0" step="5"></div>
                    <div class="mb-2"><label class="small text-light d-flex justify-content-between">Contrast <span id="contrastValue" class="text-primary">1.0</span></label><input type="range" class="form-range" id="contrast" min="0.5" max="2.5" value="1.0" step="0.05"></div>
                    <div class="mb-2"><label class="small text-light d-flex justify-content-between">Gamma <span id="gammaValue" class="text-primary">1.0</span></label><input type="range" class="form-range" id="gamma" min="0.2" max="2.2" value="1.0" step="0.1"></div>
                </div>
            </div>
        </div>
        <div id="statusContainer"></div>
    </div>

<script>
    // Elements
    const image = document.getElementById('main-image');
    const imagePane = document.getElementById('imagePane');
    const cropArea = document.getElementById('crop-area');
    const drawCanvas = document.getElementById('draw-canvas');
    const drawCtx = drawCanvas.getContext('2d');
    
    // State
    const sessionId = '{{ session_id }}';
    const imageIndex = parseInt('{{ image_index }}');
    const totalPages = parseInt('{{ total_pages }}');
    const storageKey = `cropState_${sessionId}_${imageIndex}`;
    
    let boxes = [];
    let selectedBoxIndex = -1;
    let isDrawing = false;
    let startX, startY;
    let dragTarget = null;
    let startPositions = {};
    let stitchingState = 'inactive'; 
    let destinationBoxIndex = -1;

    // --- INITIALIZATION & RESIZING LOGIC ---

    function init() {
        if (image.complete && image.naturalWidth > 0) {
            fitImageToPane();
        } else {
            image.onload = fitImageToPane;
        }
        
        window.addEventListener('resize', () => {
            requestAnimationFrame(fitImageToPane);
        });
        
        loadSettings();
        loadBoxes();
        setupListeners();
    }

    // The core fix: Calculate exact dimensions to contain image in pane without overflow
    function fitImageToPane() {
        if (!image.naturalWidth) return;

        // Get exact available space from the container
        const rect = imagePane.getBoundingClientRect();
        const availableW = rect.width - 20; // 10px padding buffer each side
        const availableH = rect.height - 20; // 10px padding buffer top/bottom

        const naturalW = image.naturalWidth;
        const naturalH = image.naturalHeight;

        // Calculate "Contain" scale
        const scale = Math.min(availableW / naturalW, availableH / naturalH);

        // Compute final dimensions
        const finalW = Math.floor(naturalW * scale);
        const finalH = Math.floor(naturalH * scale);

        // Apply to Wrapper
        cropArea.style.width = `${finalW}px`;
        cropArea.style.height = `${finalH}px`;

        // Apply to Canvas (Coordinate space)
        drawCanvas.width = finalW;
        drawCanvas.height = finalH;

        // Reposition toolbar if active and redraw
        if (selectedBoxIndex !== -1) updateToolbarPosition();
        drawBoxes();
    }

    // --- DRAWING LOGIC ---

    function drawBoxes() {
        drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        
        boxes.forEach((box, index) => {
            const isSelected = index === selectedBoxIndex;
            const isDestination = index === destinationBoxIndex;
            const isStitched = box.is_destination_for_stitch || box.stitch_to !== null;

            // Normalize to Canvas Pixels
            const p = (pt) => ({ x: pt.x * drawCanvas.width, y: pt.y * drawCanvas.height });

            drawCtx.lineWidth = isSelected ? 3 : 2;
            drawCtx.strokeStyle = isSelected ? 'red' : (isDestination ? 'cyan' : 'gold');
            drawCtx.fillStyle = isSelected ? 'rgba(255,0,0,0.1)' : 'rgba(255,215,0,0.1)';
            if (isDestination) drawCtx.fillStyle = 'rgba(0,255,255,0.2)';

            drawCtx.beginPath();
            drawCtx.moveTo(p(box.tl).x, p(box.tl).y);
            drawCtx.lineTo(p(box.tr).x, p(box.tr).y);
            drawCtx.lineTo(p(box.br).x, p(box.br).y);
            drawCtx.lineTo(p(box.bl).x, p(box.bl).y);
            drawCtx.closePath();
            drawCtx.stroke();
            drawCtx.fill();

            // Handles
            if (isSelected) {
                drawCtx.fillStyle = 'white';
                ['tl','tr','bl','br'].forEach(k => {
                    drawCtx.beginPath();
                    drawCtx.arc(p(box[k]).x, p(box[k]).y, 6, 0, Math.PI*2);
                    drawCtx.fill();
                    drawCtx.stroke();
                });
            }
            
            // Label
            const cx = (p(box.tl).x + p(box.br).x)/2;
            const cy = (p(box.tl).y + p(box.br).y)/2;
            drawCtx.font = "bold 20px sans-serif";
            drawCtx.fillStyle = "white";
            drawCtx.shadowColor="black"; drawCtx.shadowBlur=4;
            drawCtx.fillText(index + 1, cx - 5, cy + 5);
            if(isStitched) drawCtx.fillText("ðŸ”—", p(box.tr).x - 25, p(box.tr).y + 20);
            drawCtx.shadowBlur=0;
        });
    }

    // --- INTERACTION LOGIC ---

    function getPointerPos(e) {
        const rect = drawCanvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        // Normalized 0..1
        let x = (clientX - rect.left) / rect.width;
        let y = (clientY - rect.top) / rect.height;
        
        // Clamp to bounds
        return { 
            x: Math.max(0, Math.min(1, x)), 
            y: Math.max(0, Math.min(1, y)) 
        };
    }

    function hitTest(nx, ny) {
        const radius = 15 / drawCanvas.width; // approximate pixel radius in norm coords
        for (let i = boxes.length - 1; i >= 0; i--) {
            const b = boxes[i];
            // Check corners
            for(let k of ['tl','tr','bl','br']) {
                if (Math.hypot(b[k].x - nx, b[k].y - ny) < radius) return { type: 'corner', index: i, corner: k };
            }
            // Check body
            const minX = Math.min(b.tl.x, b.br.x);
            const maxX = Math.max(b.tl.x, b.br.x);
            const minY = Math.min(b.tl.y, b.br.y);
            const maxY = Math.max(b.tl.y, b.br.y);
            if (nx > minX && nx < maxX && ny > minY && ny < maxY) return { type: 'body', index: i };
        }
        return null;
    }

    function onPointerDown(e) {
        e.preventDefault(); // Stop scroll
        const {x, y} = getPointerPos(e);
        const hit = hitTest(x, y);

        if (stitchingState === 'selecting_source') {
            if (hit && hit.type === 'body' && hit.index !== destinationBoxIndex) {
                boxes[hit.index].stitch_to = boxes[destinationBoxIndex].id;
                boxes[destinationBoxIndex].is_destination_for_stitch = true;
            }
            cancelStitch();
            return;
        }

        if (hit) {
            dragTarget = hit;
            selectBox(hit.index);
            startPositions = JSON.parse(JSON.stringify(boxes[hit.index]));
            startX = x; startY = y;
            isDrawing = false;
        } else {
            selectBox(-1);
            isDrawing = true;
            startX = x; startY = y;
        }
        
        document.addEventListener('mousemove', onPointerMove);
        document.addEventListener('touchmove', onPointerMove, { passive: false });
        document.addEventListener('mouseup', onPointerUp);
        document.addEventListener('touchend', onPointerUp);
    }

    function onPointerMove(e) {
        e.preventDefault();
        const {x, y} = getPointerPos(e);
        const dx = x - startX;
        const dy = y - startY;

        if (dragTarget) {
            const b = boxes[dragTarget.index];
            if (dragTarget.type === 'corner') {
                b[dragTarget.corner].x = x;
                b[dragTarget.corner].y = y;
            } else {
                ['tl','tr','bl','br'].forEach(k => {
                    b[k].x = startPositions[k].x + dx;
                    b[k].y = startPositions[k].y + dy;
                });
            }
            drawBoxes();
            updateToolbarPosition();
        } else if (isDrawing) {
            drawBoxes();
            const sx = startX * drawCanvas.width;
            const sy = startY * drawCanvas.height;
            const w = (x - startX) * drawCanvas.width;
            const h = (y - startY) * drawCanvas.height;
            drawCtx.strokeStyle = 'rgba(255,0,0,0.5)';
            drawCtx.strokeRect(sx, sy, w, h);
        }
    }

    function onPointerUp(e) {
        if (isDrawing) {
            // Use Changed touches if available
            const rect = drawCanvas.getBoundingClientRect();
            const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
            let endX = (clientX - rect.left) / rect.width;
            let endY = (clientY - rect.top) / rect.height;
            
            // Clamp
            endX = Math.max(0, Math.min(1, endX));
            endY = Math.max(0, Math.min(1, endY));

            if (Math.abs(endX - startX) * drawCanvas.width > 15 && Math.abs(endY - startY) * drawCanvas.height > 15) {
                boxes.push({
                    id: Date.now(),
                    tl: { x: Math.min(startX, endX), y: Math.min(startY, endY) },
                    tr: { x: Math.max(startX, endX), y: Math.min(startY, endY) },
                    bl: { x: Math.min(startX, endX), y: Math.max(startY, endY) },
                    br: { x: Math.max(startX, endX), y: Math.max(startY, endY) },
                    stitch_to: null, is_destination_for_stitch: false
                });
                selectBox(boxes.length - 1);
            }
        }
        
        isDrawing = false; dragTarget = null;
        saveBoxes();
        drawBoxes();
        document.removeEventListener('mousemove', onPointerMove);
        document.removeEventListener('touchmove', onPointerMove);
        document.removeEventListener('mouseup', onPointerUp);
        document.removeEventListener('touchend', onPointerUp);
    }

    // --- GUI & ACTIONS ---

    function selectBox(i) {
        selectedBoxIndex = i;
        const tb = document.getElementById('box-toolbar');
        if (i === -1) {
            tb.style.display = 'none';
        } else {
            tb.style.display = 'flex';
            updateToolbarPosition();
        }
        drawBoxes();
    }

    function updateToolbarPosition() {
        if (selectedBoxIndex === -1) return;
        const b = boxes[selectedBoxIndex];
        const tb = document.getElementById('box-toolbar');
        
        // Place at bottom-right of box
        const x = Math.max(b.tl.x, b.br.x) * drawCanvas.width;
        const y = Math.min(b.tl.y, b.br.y) * drawCanvas.height;
        
        // Clamp to screen
        let left = x - tb.offsetWidth;
        let top = y - tb.offsetHeight - 5;
        if (left < 0) left = 0;
        if (top < 0) top = y + 10;
        
        tb.style.left = left + 'px';
        tb.style.top = top + 'px';
    }

    function setupListeners() {
        drawCanvas.addEventListener('mousedown', onPointerDown);
        drawCanvas.addEventListener('touchstart', onPointerDown, {passive:false});
        
        document.getElementById('clearBtn').addEventListener('click', () => { 
            if(confirm("Delete all boxes?")) { boxes=[]; selectBox(-1); saveBoxes(); }
        });
        
        document.getElementById('backBtn').addEventListener('click', () => {
             window.location.href = (imageIndex > 0) ? `/cropv2/${sessionId}/${imageIndex-1}` : `/v2`;
        });

        document.getElementById('delete-btn').addEventListener('click', () => {
            if (selectedBoxIndex > -1) { boxes.splice(selectedBoxIndex, 1); selectBox(-1); saveBoxes(); }
        });
        
        document.getElementById('stitch-btn').addEventListener('click', () => {
            stitchingState = 'selecting_source';
            destinationBoxIndex = selectedBoxIndex;
            const instr = document.getElementById('stitch-instructions');
            instr.innerHTML = 'Tap next box to stitch. <button class="btn-close btn-sm float-end" onclick="cancelStitch()"></button>';
            instr.style.display = 'block';
        });

        document.getElementById('processBtn').addEventListener('click', processPage);
        
        // Filter sliders
        ['brightness','contrast','gamma'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateFilters);
        });
    }
    
    window.cancelStitch = function() {
        stitchingState = 'inactive';
        document.getElementById('stitch-instructions').style.display = 'none';
        drawBoxes();
    }

    function updateFilters() {
        const b = document.getElementById('brightness').value;
        const c = document.getElementById('contrast').value;
        const g = document.getElementById('gamma').value; // Visual approximation
        
        image.style.filter = `brightness(${100 + parseFloat(b)}%) contrast(${c})`;
        
        document.getElementById('brightnessValue').innerText = b;
        document.getElementById('contrastValue').innerText = c;
        document.getElementById('gammaValue').innerText = g;
        
        localStorage.setItem('pdfFilters', JSON.stringify({b,c,g}));
    }
    
    function loadSettings() {
        try {
            const s = JSON.parse(localStorage.getItem('pdfFilters'));
            if(s) {
                document.getElementById('brightness').value = s.b;
                document.getElementById('contrast').value = s.c;
                document.getElementById('gamma').value = s.g;
                updateFilters();
            }
        } catch(e){}
    }

    async function processPage() {
        if(boxes.length === 0) {
            if(!confirm("No boxes drawn. Skip page?")) return;
        }
        
        const btn = document.getElementById('processBtn');
        btn.disabled = true;
        document.getElementById('loader-overlay').style.display = 'flex';

        // Prepare Normalized Boxes
        const finalBoxes = boxes.map(b => {
            const minX = Math.min(b.tl.x, b.bl.x);
            const minY = Math.min(b.tl.y, b.tr.y);
            const maxX = Math.max(b.tr.x, b.br.x);
            const maxY = Math.max(b.bl.y, b.br.y);
            return { ...b, x: minX, y: minY, w: maxX - minX, h: maxY - minY };
        });

        // Capture current filter state visually
        const tempCv = document.createElement('canvas');
        tempCv.width = image.naturalWidth;
        tempCv.height = image.naturalHeight;
        const tCtx = tempCv.getContext('2d');
        tCtx.filter = image.style.filter;
        tCtx.drawImage(image, 0, 0);
        const imgData = tempCv.toDataURL('image/jpeg', 0.85);

        try {
            const res = await fetch('/process_crop_v2', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    session_id: sessionId,
                    image_index: imageIndex,
                    boxes: finalBoxes,
                    imageData: imgData
                })
            });
            if(!res.ok) throw new Error('Server Error');
            
            localStorage.removeItem(storageKey);
            window.location.href = (imageIndex + 1 < totalPages) 
                ? `/cropv2/${sessionId}/${imageIndex+1}` 
                : `/question_entry_v2/${sessionId}`;
                
        } catch (err) {
            alert("Error processing: " + err.message);
            btn.disabled = false;
            document.getElementById('loader-overlay').style.display = 'none';
        }
    }

    function saveBoxes() { localStorage.setItem(storageKey, JSON.stringify(boxes)); }
    function loadBoxes() {
        try {
            const s = localStorage.getItem(storageKey);
            if(s) {
                boxes = JSON.parse(s);
                // Ensure IDs
                boxes.forEach((b,i) => { if(!b.id) b.id = Date.now()+i; });
                drawBoxes();
            }
        } catch(e){}
    }

    init();
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
